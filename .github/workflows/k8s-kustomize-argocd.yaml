name: CI/CD Pipeline with Dynamic Kustomize

on:
  workflow_dispatch:
    inputs:
      application:
        description: "Select application type"
        required: true
        type: choice
        options:
          - go-api
          - java-api
          - python-api
          - frontend
          - backend
      aws_region:
        description: "Select AWS Region"
        required: true
        type: choice
        options:
          - us-east-1
          - us-west-2
      env_name:
        description: "Select Environment"
        required: true
        type: choice
        options:
          - dev
          - test
          - prod
      modifications:
        description: "Enter runtime modifications as JSON (Only for go-api & java-api)"
        required: false
        default: "{}"
      atlas_repository:
        description: "Enter your Atlas repository where manifests should be pushed"
        required: true

jobs:
  build-and-test:
    name: Build and Test Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Setup Docker
        uses: docker/setup-buildx-action@v2

      - name: Build Docker Image
        run: |
          docker build -t my-app:$GITHUB_SHA .

      - name: Login to JFrog Artifactory
        env:
          ARTIFACTORY_URL: ${{ secrets.ARTIFACTORY_URL }}
          ARTIFACTORY_USER: ${{ secrets.ARTIFACTORY_USER }}
          ARTIFACTORY_PASSWORD: ${{ secrets.ARTIFACTORY_PASSWORD }}
        run: |
          echo $ARTIFACTORY_PASSWORD | docker login -u $ARTIFACTORY_USER --password-stdin $ARTIFACTORY_URL

      - name: Tag and Push Image to Artifactory
        env:
          ARTIFACTORY_URL: ${{ secrets.ARTIFACTORY_URL }}
        run: |
          docker tag my-app:$GITHUB_SHA $ARTIFACTORY_URL/docker-local/my-app:$GITHUB_SHA
          docker push $ARTIFACTORY_URL/docker-local/my-app:$GITHUB_SHA


  manage-manifests:
    name: Manage Kubernetes Manifests
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Kustomize Repository
        uses: actions/checkout@v3
        with:
          repository: bgcodehub/kustomize-application
          path: kustomize-base

      - name: Install Dependencies
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          sudo apt-get install -y jq
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
          curl -LO https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64.tar.gz
          tar xf kubeconform-linux-amd64.tar.gz
          sudo mv kubeconform /usr/local/bin/

      - name: Validate Application Customization
        run: |
          if [[ "${{ github.event.inputs.application }}" != "go-api" && "${{ github.event.inputs.application }}" != "java-api" && "${{ github.event.inputs.modifications }}" != "{}" ]]; then
            echo "‚ùå Error: Runtime customization is only allowed for go-api and java-api"
            exit 1
          fi

      - name: Apply Runtime Modifications
        if: ${{ github.event.inputs.application == 'go-api' || github.event.inputs.application == 'java-api' }}
        run: |
          FILE=""
      
          # Determine which file to modify based on the application type
          if [[ "${{ github.event.inputs.application }}" == "go-api" ]]; then
            FILE="kustomize-base/go-api/overlays/patches/deploy.yaml"
          elif [[ "${{ github.event.inputs.application }}" == "java-api" ]]; then
            FILE="kustomize-base/java-api/overlays/patches/deploy.yaml"
          fi
      
          echo "üîπ Applying runtime modifications to $FILE"
          
          # Read and process JSON modifications
          echo '${{ github.event.inputs.modifications }}' | jq -r 'to_entries | .[] | "\(.key) = \(.value)"' | while read -r line; do
            KEY=$(echo "$line" | cut -d'=' -f1 | xargs)
            VALUE=$(echo "$line" | cut -d'=' -f2 | xargs)
            echo "  - $KEY: $VALUE"
      
            if [[ "$KEY" == "timeout_seconds" || "$KEY" == "initial_delay_seconds" || "$KEY" == "revision_history_limit" || "$KEY" == "termination_grace_period_seconds" || "$KEY" == "max_replicas" ]]; then
              VALUE=$(echo "$VALUE" | jq 'tonumber')  # Convert string to number
            fi
      
            case "$KEY" in
              cpu_limit)
                yq -i '.spec.template.spec.containers[0].resources.limits.cpu = "'"$VALUE"'"' $FILE ;;
              memory_limit)
                yq -i '.spec.template.spec.containers[0].resources.limits.memory = "'"$VALUE"'"' $FILE ;;
              cpu_request)
                yq -i '.spec.template.spec.containers[0].resources.requests.cpu = "'"$VALUE"'"' $FILE ;;
              memory_request)
                yq -i '.spec.template.spec.containers[0].resources.requests.memory = "'"$VALUE"'"' $FILE ;;
              timeout_seconds)
                yq -i '.spec.template.spec.containers[0].livenessProbe.timeoutSeconds = '$VALUE'' $FILE ;;
              initial_delay_seconds)
                yq -i '.spec.template.spec.containers[0].livenessProbe.initialDelaySeconds = '$VALUE'' $FILE ;;
              revision_history_limit)
                yq -i '.spec.revisionHistoryLimit = '$VALUE'' $FILE ;;
              termination_grace_period_seconds)
                yq -i '.spec.template.spec.terminationGracePeriodSeconds = '$VALUE'' $FILE ;;
              max_replicas)
                yq -i '.spec.maxReplicas = '$VALUE'' "kustomize-base/java-api/overlays/patches/hpa.yaml" ;;
              *)
                echo "‚ùå Error: Invalid key '$KEY'. Skipping."
                continue ;;
            esac
          done
      
          echo "‚úÖ Updates completed successfully!"

      - name: Generate Kubernetes ConfigMap with AWS Region and Environment
        run: |
          CONFIG_DIR="kustomize-base/${{ github.event.inputs.application }}/overlays/config"
          mkdir -p "$CONFIG_DIR"

          # Ensure ConfigMap is correctly generated as a standalone resource
          cat <<EOF > "$CONFIG_DIR/aws-configmap.yaml"
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: aws-config
          data:
            AWS_REGION: "${{ github.event.inputs.aws_region }}"
            ENV_NAME: "${{ github.event.inputs.env_name }}"
          EOF

          echo "‚úÖ AWS ConfigMap generated at $CONFIG_DIR/aws-configmap.yaml"

      - name: Update Kustomization to Include ConfigMap
        run: |
          KUSTOMIZATION_FILE="kustomize-base/${{ github.event.inputs.application }}/overlays/kustomization.yaml"

          # Ensure ConfigMapGenerator correctly references the ConfigMap
          if ! grep -q "configMapGenerator" "$KUSTOMIZATION_FILE"; then
            echo -e "\nconfigMapGenerator:" >> "$KUSTOMIZATION_FILE"
          fi

          # Add configMapGenerator for AWS Config (Prevent duplicate entries)
          if ! grep -q "name: aws-config" "$KUSTOMIZATION_FILE"; then
            echo "  - name: aws-config" >> "$KUSTOMIZATION_FILE"
            echo "    literals:" >> "$KUSTOMIZATION_FILE"
            echo "      - AWS_REGION=${{ github.event.inputs.aws_region }}" >> "$KUSTOMIZATION_FILE"
            echo "      - ENV_NAME=${{ github.event.inputs.env_name }}" >> "$KUSTOMIZATION_FILE"
          fi

          echo "‚úÖ Kustomization updated to include AWS ConfigMap."

      - name: Update Deployment to Reference ConfigMap
        run: |
          DEPLOYMENT_FILE="kustomize-base/${{ github.event.inputs.application }}/overlays/patches/deploy.yaml"

          # Ensure the deployment correctly references the standalone ConfigMap
          yq -i '.spec.template.spec.containers[0].env += [{"name": "AWS_REGION", "valueFrom": {"configMapKeyRef": {"name": "aws-config", "key": "AWS_REGION"}}}]' $DEPLOYMENT_FILE
          yq -i '.spec.template.spec.containers[0].env += [{"name": "ENV_NAME", "valueFrom": {"configMapKeyRef": {"name": "aws-config", "key": "ENV_NAME"}}}]' $DEPLOYMENT_FILE

          echo "‚úÖ Deployment updated to reference ConfigMap values."

      - name: Update Image in Kustomize Manifest (All Applications)
        env:
          ARTIFACTORY_URL: ${{ secrets.ARTIFACTORY_URL }}
        run: |
          IMAGE_URL="$ARTIFACTORY_URL/docker-local/my-app:$GITHUB_SHA"
          FILE="kustomize-base/${{ github.event.inputs.application }}/overlays/patches/deploy.yaml"

          echo "üîπ Updating image in $FILE to $IMAGE_URL"
          yq -i '.spec.template.spec.containers[0].image = "'"$IMAGE_URL"'"' $FILE
          echo "‚úÖ Image updated successfully!"

      - name: Apply Kustomize Overlays and Output New Configuration
        run: |
          APP_DIR="${{ github.event.inputs.application }}"
          mkdir -p "$APP_DIR"
          kustomize build "kustomize-base/${{ github.event.inputs.application }}/overlays/" > "$APP_DIR/deployment.yaml"
          echo "üìù New Updated Configuration:"
          cat "$APP_DIR/deployment.yaml"
  
      - name: Validate Kubernetes Manifests with Kubeconform
        run: |
          kubeconform -strict -summary -ignore-missing-schemas -schema-location default "${{ github.event.inputs.application }}/deployment.yaml"

      - name: Configure Git for Unsigned Commits
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global commit.gpgsign false
          git config --global gpg.program ""

      - name: Push Manifests to Atlas Repository
        env:
          GITHUB_TOKEN: ${{ secrets.ATLAS_GITHUB_PAT }}
        run: |
          set -e  # Exit script immediately on error

          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          # Extract repository URL from input and inject GITHUB_TOKEN for authentication
          REPO_URL=${{ github.event.inputs.atlas_repository }}
          AUTH_REPO_URL="https://x-access-token:${GITHUB_TOKEN}@${REPO_URL#https://}"

          # Define the target branch based on the environment selection
          TARGET_BRANCH="${{ github.event.inputs.env_name }}"

          echo "üì• Cloning Atlas repository branch: $TARGET_BRANCH..."
          git clone --branch "$TARGET_BRANCH" "$AUTH_REPO_URL" atlas
          
          # Determine the target region-based directory
          if [[ "${{ github.event.inputs.aws_region }}" == "us-east-1" ]]; then
            TARGET_DIR="use1-01"
          elif [[ "${{ github.event.inputs.aws_region }}" == "us-west-2" ]]; then
            TARGET_DIR="usw2-01"
          else
            echo "‚ùå Error: Invalid AWS Region selected."
            exit 1
          fi

          # Construct final destination path within the Atlas repository
          FINAL_PATH="atlas/$TARGET_DIR/${{ github.event.inputs.application }}"

          echo "üìÇ Ensuring the directory structure exists: $FINAL_PATH"
          mkdir -p "$FINAL_PATH"

          # Move the entire application folder (instead of just deployment.yaml)
          echo "üì§ Copying deployment files to $FINAL_PATH..."
          cp -r "${{ github.event.inputs.application }}"/* "$FINAL_PATH/"

          # Navigate to the Atlas repo
          cd atlas

          echo "üßê Checking for changes..."
          git status
          git diff || echo "‚ÑπÔ∏è No changes detected by git diff"

          # Force Git to detect changes even if metadata hasn't changed
          git add -A

          # Ensure Git recognizes new files
          git ls-files --others --exclude-standard

          # If there are no changes, prevent unnecessary commits
          if git diff --cached --quiet; then
            echo "‚úÖ No changes detected. Skipping commit."
            exit 0
          fi

          echo "‚úÖ Changes detected. Committing..."
          git commit -m "feat(deploy): update ${{ github.event.inputs.application }} manifests for ${{ github.event.inputs.env_name }} in ${{ github.event.inputs.aws_region }} - $GITHUB_SHA"

          echo "üöÄ Pushing changes to branch: $TARGET_BRANCH..."
          git push origin "$TARGET_BRANCH"

  # trigger-argocd:
  #   name: Trigger ArgoCD Deployment
  #   needs: manage-manifests
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Sync ArgoCD
  #       env:
  #         ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
  #         ARGOCD_TOKEN: ${{ secrets.ARGOCD_TOKEN }}
  #       run: |
  #         curl -k -X POST "$ARGOCD_SERVER/api/v1/applications/my-app/sync" \
  #         -H "Authorization: Bearer $ARGOCD_TOKEN"

  # post-deployment:
  #   name: Post-Deployment Verification
  #   needs: trigger-argocd
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Notify Developers
  #       env:
  #         SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
  #       run: |
  #         curl -X POST -H 'Content-type: application/json' --data '{"text":"Deployment succeeded for $GITHUB_SHA"}' $SLACK_WEBHOOK